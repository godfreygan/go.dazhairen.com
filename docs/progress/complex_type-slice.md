# 切片

切片是Go语言中比较特别的数据结构，这种数据结构更便于使用和管理数据集合。  
切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。  
切片的动态增长是通过内置函数 append() 来实现的，这个函数可以快速且高效的增长切片，也可以通过对切片再次切割，缩小一个切片的大小。  
因为切片的底层也是在连续内存块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。


## 创建数组切片

### make和切片字面量

一种创建切片的方法是使用内置的 make() 函数。当使用 make() 函数时，需要传入一个参数，指定切片的长度：`slice := make([]string, 5)`
如果只指定长度，那么切片的容量和长度相等。也可以分别指定长度和容量：`slice := make([]string, 3, 5)`
分别指定长度和容量时，创建出来的切片的底层数组长度就是创建时指定的容量，但是初始化后并不能访问所有的数组元素。  
如上面定义的切片，可以访问3个元素，而底层数组拥有5个元素，因此剩余的2个元素可以在后期操作中合并到切片，然后才可以通过切片访问这些元素。

另一种常用的创建切片的方法是使用切片字面量，如：`slice := []string{"red", "blue", "green", "yellow", "pink"}`
这种方法和创建数组类似，只是不需要指定[]运算符里的值，初始的长度和容量会基于初始化时提供的元素的个数确定。

### nil和空切片

有时程序可能需要声明一个值为nil的切片（也称nil切片或空切片）。只要在声明时不做任何初始化，就会创建一个nil切片，如：`var slice []int`

在Go语言里，nil切片是很常见的创建切片的方法。nil切片多用于标准库和内置函数，在需要描述一个目前暂时不存在的切片时，nil切片就显得十分好用。
```
slice := make([]int, 0)
slice2 := []string{}
```

此外，nil切片还可以用来表示空集合。例如，数据库查询返回0个查询结果。nil切片和普通切片一样，调用内置函数append、len和cap的效果一样的。


## 切片的使用

### 赋值和分割

给切片的某个元素赋值和给数组的某个元素赋值在方法上完全一样，使用[]运算符就可以改变某个元素的值。
```
slice := []int{10, 20, 30, 50}
slice[1] = 25
```

切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分。例如：
```
// 创建一个整型切片，其长度和容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新的切片，其长度为2个元素，容量为4个元素
newSlice := slice[1:3]
// 使用3个索引创建切片
newSlice2 := slice[2:3:4]
```
上面代码中，创建了两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分。
第一个切片slice能够访问底层数组全部5个元素的容量，不过之后的newSlice就访问不到了。对于newSlice，底层数组的容量只有4个元素。newSlice无法访问到它所指向的底层数组的第一个元素之前的部分。换而言之，对于newSlice来说，之前的那些元素是不存在的。

一个常见的描述是，对底层数组容量是k的切片 slice[i:j:k] 来说，长度是 j-i，容量是 k-i。

两个切片共享同一个底层数组，如果一个切片修改了该底层数组的共享部分，另一个切片也会被影响。
```
// 创建一个整型切片，其长度和容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新的切片，其长度是2个元素，容量是4个元素
newSlice := slice[1:3]
// 修改newSlice索引为1的元素，同时也修改了原来的slice的索引为2的元素
newSlice[1] = 35
```

### 切片扩容

相对于数组而言，使用切片的一个好处是可以按需增加数据集合的容量。Go语言内置的 append() 函数会处理增加长度时的所有操作细节。
```
// 创建一个整型切片，其长度和容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新切片，其长度为2个元素，容量为4个长度
newSlice := slice[1:3]
// 使用原有的容量来分配一个新元素
newSlice = append(newSlice, 60)
```

### 遍历切片

既然切片是一个集合，那么自然可以迭代其中的元素。  
和数组类似，迭代切片时，range会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一个实际值。
```
slice := []int{10, 20, 30, 40, 50}
for index, value := range slice {
    fmt.Printf("index: %d: %d\n", index, value)
}
```

### 限制容量

在创建切片时，还可以使用之前没有提及的第三个索引选项。  
第三个索引可以用来控制新切片的容量，其目的并不是要增加容量，而是要限制容量。
```
// 创建字符串切片，其长度和容量都是5个元素
source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
// 对第三个元素做切片，并限制容量，其长度和容量都是1个元素
slice := source[2:3:3]
// 向slice追加新字符
slice = append(slice, "Kiwi")
```


## 多维切片

和数组一样，切片也是一维的。同样，也可以组合多个切片形成多维切片。
```
// 创建一个二维整型切片
slice := [][]int{{10}, {20, 30}, {40, 50, 60}}

// 为第一个切片追加值为15的元素
slice[0] = append(slice[0], 15)
```


## 将切片传递给函数

切片结构简单，尺寸很小，在函数间传递切片可以以值的方式传递。同数组不同，切片在函数间复制和传递的成本很低。
因为，与切片关联的数据包含在底层数组里，不属于切片本身。

```
slice := make([]int, 1e6)
slice = foo(slice)
func foo(slice []int) []int {
    // todo
    return slice
}
```


