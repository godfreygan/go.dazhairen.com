# 数组

数组是具有相同类型的一组已经编号且长度固定的数据项序列，这个序列可以是有序的也可以是无序的，组成数组的各个变量称为数组的元素。  
这种类型可以是任意的原始类型，例如int、string或者自定义类型。数组长度必须是一个非负整数的常量（或常量表达式），数组长度也是数组类型的一部分，所以 [20]int 和 [100]int 不是同一种类型。


## 声明

数组的声明需要指定元素的数据类型，以及存储元素的数量（数组的长度）：`var arrayName [length]type`

数组一旦声明，它存储的数据类型和数组长度便不能修改了。  
所以如果需要存储更多的元素，必须先创建一个更长的数组，然后再把原来数组里的值复制到新数组里。

使用数组字面量可以快速创建并初始化数组，数组字面量可以声明数组里的元素的数量，并指定每个元素的值，如下面代码所示：
`array := [5]int{10, 20, 30, 40, 50}`

如果使用...代替数组的长度，Go语言会根据初始化时数组元素的数量来确定该数组的长度，如下面代码所示：
`array := [...]int{10, 20, 30, 40, 50}`

如果知道数组的长度，还可以给特定下标指定具体值，如下面代码所示：
`array := [5]int{1:10, 2:20}`


## 访问

和其它类C语言一样，Go语言数组通过数组下标（索引位置）来读取或者修改数组元素，下标（索引）从0开始，第一个元素索引为0，第二个索引为1，以此类推。  
元素的数目（长度或数组大小）必须是固定的并且在声明数组时就指定的（编译时需要知道数组长度以便分配内存），数组长度最大为2GB。

```go
package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4}
    for i := 0; i < len(arr); i++ {
        fmt.Printf("Array at index %d is %d\n", i, arr[i])
    }
}
```


## 修改

数组时效率很高的数据结构，因为数组在内存分配中是连续的，要访问数组里某个单独元素，使用[]运算符即可，如：`arr[2] = 20`
```
array := [5]int{1, 2, 3, 4, 5}
array[2] = 30
```

数组的值也可以是指针，使用\*运算符就可以访问元素指针所指向的值：
```
arr := [5]*int{0: new(int), 1: new(int)}
*arr[0] = 10
*arr[1] = 20
```


## 多维数组

数组本身只有一个维度，可以组合多个数组来创建多维数组。多维数组用于管理具有依赖关系的数据（例如坐标系等）。
示例：
```go
package main

import "fmt"

func main() {
    // 声明一个二维整型数组，两个维度分别存储4个元素和2个元素
    var array1 [4][2]int
    fmt.Println(array1)
    
    // 使用数组字面量来声明并初始化一个二维数组
    array2 := [4][2]int{{2, 4}, {6, 8}, {10, 12}, {14, 16}}
    fmt.Println(array2)
    
    // 声明并初始化外层数组中索引为1和3的元素
    array3 := [4][2]int{1: {100, 200}, 3: {110, 120}}
    fmt.Println(array3)
    
    // 声明并初始化外层数组和内层数组的单个元素
    array4 := [4][2]int{1: {0: 60}, 3: {1: 79}}
    fmt.Println(array4)
}
```

和一维数组一样，通过数组下标可以修改或访问数组元素：
```go
package main

import "fmt"

func main() {
    var array [2][2]int
    array[1][0] = 100
    fmt.Println(array[1][0])
}
```


## 将数组传递给函数

在Go语言中数组是一个值类型，所有的值类型变量在赋值和作为参数传递时都将执行一次复制动作。  
如果直接将数组作为函数的参数，则在函数调用时会复制一份作为函数参数。
如此一来，从内存和性能角度来说，在函数间传递数组是一个比较大的开销。更好且更高效的方法是，只传递指向数组的指针。

示例1：
```
var array [1e6]int
foo(array)
 
func foo(array [1e6]int) {
    // todo
}
```

示例2：
```
var array [1e6]int
foo(&array)

func foo(array *[1e6]int) {
    // todo
}
```

上述两个例子中，第一个例子中，假设数组需要10M内存，每次函数调用时，都会在栈中分配10M内存；
而第二个例子，每次函数调用时，只需在栈中分配几个字节的内存给指针。  
所以在开发中，根据数据量的大小合理使用函数传递方式会更有效利用内存。